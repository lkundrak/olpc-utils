#!/usr/bin/python
"""Sudo clone using su under the hood."""
# Copyright (C) 2008 One Laptop Per Child Association, Inc.
# Licensed under the terms of the GNU GPL v2 or later; see COPYING for details.
# Written by C. Scott Ananian <cscott@laptop.org>
import os, pwd

VERSION=(1,3)
VERSION_INFO =\
"""olpc-sudo %(major)s.%(minor)s, Copyright (C) 2008 One Laptop Per Child Association, Inc.
This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License v2 or later: http://www.gnu.org/licenses/gpl.html
There is NO WARRANTY, to the extent permitted by law.

Written by C. Scott Ananian.
""" % { 'major': VERSION[0], 'minor': VERSION[1] }

def shell_escape(s):
    """Escape the given string for the shell."""
    def esc(c):
        # hmph.  we can't tell if the subshell will unescape '\!' or not =(
        # we'll play it safe, but be careful if your strings include !
        if c in [ '$', '`', '\\', '!', "\n", '"' ]:
            return '\\%c' % c
        else:
            return c
    return '"%s"' % (''.join(esc(c) for c in s))

def main():
    from optparse import OptionParser
    parser = OptionParser(version=VERSION_INFO, usage="""
 %prog -h | -K | -k | -L | -l | -V | -v
 %prog [-bEHPS] [-a auth_type] [-c class|-] [-p prompt] [-u user-name|#uid] [VAR=value] {-i | -s | command}
""")
    parser.disable_interspersed_args() # stop parsing options at first command
    parser.add_option('-V', action='version', help='Print the version number and exit')
    parser.add_option('-K', '-k', '-v', action='store_true', dest='_',
                      help='These options are present for compatibility, but are ignored.')
    parser.add_option('-a', '-c', '-p', action='store', nargs=1, dest='_',
                      help='These options are present for compatibility, but are ignored.')
    parser.add_option('-i', action='store_true', dest='login',
                      help='Simulate initial login.')
    parser.add_option('-s', action='store_true', dest='shell',
                      help='Runs the shell specified by the SHELL environment variable.')
    parser.add_option('-u', action='store', dest='user', nargs=1,
                      help='Run the specified command as a user other than root. ')
    parser.add_option('-H', action='store_true', dest='home',
                      help='Sets the HOME environment variable to the homedir of the target user.')
    parser.add_option('-E', action='store_true', dest='preserve',
                      help='Preserve environment.')
    parser.set_defaults(user='root', shell=False, login=False, home=False,
                        preserve=False)
    (options, args) = parser.parse_args()
    cmd = [ '/bin/su' ]
    nenv = {}
    nenv.update(os.environ)
    # get pwd entry.
    # (map uid to username if options.user starts with '#')
    if options.user.startswith('#'):
        p = pwd.getpwuid(int(options.user[1:]))
    else:
        p = pwd.getpwnam(options.user)
    shell = os.environ.get('SHELL', p.pw_shell)
    extra = {}
    # process extra environment variables.
    while args and '=' in args[0] and not '--' == args[0]:
        var, val = args[0].split('=', 1)
        extra[var] = val
        args = args[1:]

    if len(args) > 0:
        if options.login or options.shell:
            parser.error('use either -s/-i or arguments, not both')
    if options.login or options.shell:
        if options.login and options.shell:
            parser.error('use either -s or -i, not both')
    elif len(args) == 0:
        parser.error('no command given')
    if options.login or options.shell:
        cmd.extend(['--shell', shell])
    if not options.preserve:
        # both debian and redhat sudo allow a slightly larger set of env
        # vars.
        for k in nenv.keys():
            if k not in ['TERM', 'PATH', 'HOME', 'SHELL', 'LOGNAME',
                         'USER', 'USERNAME', 'DISPLAY', 'XAUTHORIZATION',
                         'XAUTHORITY', 'TZ', 'PS2', 'PS1', 'PATH', 'MAIL',
                         'LS_COLORS', 'KRB5CCNAME', 'HOSTNAME', 'COLORS',
                         'SUGAR_PATH' ]:
                del nenv[k]
    if options.login:
        # change to user's homedir
        try:
            os.chdir(p.pw_dir)
        except:
            pass # might not succeed, due to perms; 'su -l' should chdir anyway
        # set environment
        nenv = {}
        nenv['HOME'] = p.pw_dir
        nenv['SHELL'] = p.pw_shell
        nenv['USER'] = nenv['LOGNAME'] = p.pw_name
        # preserve these env vars.
        for k in ['PATH', 'DISPLAY', 'XAUTHORITY', 'XAUTHORIZATION',
                  'SUGAR_PATH', 'TERM', 'HOSTNAME' ]:
            if k in os.environ: nenv[k] = os.environ[k]
    if options.home:
        nenv['HOME'] = p.pw_dir
    if options.login:
        # note that 'su -l' erases SUGAR_PATH.
        cmd.append('-l')
    elif len(args) > 0:
        cmd.append('-c')
        cmd.append(' '.join(shell_escape(s) for s in args))
    cmd.append('-p') # we take care of cleaning the environment.
    cmd.append(p.pw_name)
    nenv.update(extra)
    os.execvpe('/bin/su', cmd, nenv)

if __name__ == '__main__': main()
